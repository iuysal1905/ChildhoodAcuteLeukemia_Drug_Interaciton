# -*- coding: utf-8 -*-
"""losemi_ddi.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1lDD387qWLbkIz5opefNATA3flncIJg8K
"""

pip install pyvis

pip install networkx[default]

pip install datapane

from google.colab import drive
drive.mount('/content/drive')

import pandas as pd
import numpy as np
data2 = pd.read_excel("drive/MyDrive/leukemia_ddi.xlsx")

import networkx as nx
# Generate a networkx graph
G2 = nx.from_pandas_edgelist(data2, 'drug1_name', 'drug2_name')

# Give the graph a name
G2.name = 'Drug Interactions Network'

# Get graph density
density2 = nx.density(G2)
print("Network density:", density2)

import numpy as np
import matplotlib.pyplot as plt
import re
import zipfile
import json
from pyvis.network import Network
from operator import itemgetter
import networkx as nx
from networkx.algorithms import community #This part of networkx, for community detection, needs to be imported separately
import datapane as dp

from IPython.core.display import display, HTML
display(HTML(""))

from operator import itemgetter
# Create dictionary to store degrees of nodes
degree_dict2 = dict(G2.degree(G2.nodes()))
nx.set_node_attributes(G2, degree_dict2, 'degree')

# Generate sorted list of tuples of drug entity and corresponding degree
sorted_degree2 = sorted(degree_dict2.items(), key=itemgetter(1), reverse=True)

print("Top 20 drugs by degree:")
for d in sorted_degree2[:5]:
    print(d)

# Get most connected node (i.e. drug with most drug interactions)
G2.degree()
max(dict(G2.degree()).items(), key = lambda x : x[1])

# Get all degree values
sorted_degree_values2 = [pair[1] for pair in sorted_degree2]

# Set fixed bin size
bins = np.arange(0, 450, 2) # fixed bin size

# Plot histogram
plt.xlim([min(sorted_degree_values2)-15, max(sorted_degree_values2)+15])
plt.hist(sorted_degree_values2, bins=bins, alpha=0.5)
plt.title('Node degree distribution (fixed bin size)')
plt.xlabel('degree')
plt.ylabel('count')
plt.show()

# Get degree centrality (corresponds with degree)
degree_centrality2 = nx.degree_centrality(G2)
degree_centrality2 = dict(sorted(degree_centrality2.items(), key=lambda item: item[1], reverse=True))
degree_centrality2

# Define function to generate Pyvis visualization
def generate_network_viz(df, source_col, target_col, weights, 
                         layout='barnes_hut',
                         central_gravity=0.15,
                         node_distance=420,
                         spring_length=100,
                         spring_strength=0.15,
                         damping=0.96
                         ):
    
    # Generate a networkx graph
    G = nx.from_pandas_edgelist(df, source_col, target_col, weights)
    
    if layout == 'repulsion':
        bgcolor, font_color = '#222222', 'white'
    else:
        bgcolor, font_color = 'white', 'black'
    
    # Initiate PyVis network object
    drug_net = Network(
                       height='700px', 
                       width='100%',
                       bgcolor=bgcolor, 
                       font_color=font_color, 
                       notebook=True
                      )
    
    # Take Networkx graph and translate it to a PyVis graph format
    drug_net.from_nx(G)
    
    # Create different network layout (repulsion or Barnes Hut)
    if layout == 'repulsion':
        drug_net.repulsion(
                            node_distance=node_distance, 
                            central_gravity=central_gravity, 
                            spring_length=spring_length, 
                            spring_strength=spring_strength, 
                            damping=damping
                           )
        
    # Run default Barnes Hut visualization
    else:
        drug_net.barnes_hut(
#                            gravity=-80000, 
#                            central_gravity=central_gravity, 
#                            spring_length=spring_length, 
#                            spring_strength=spring_strength, 
#                            damping=damping, 
#                            overlap=0
                          )      
        
    # Set additional options for the graph (optional)
    # db_net_sm.set_options("""
#             var options = {
#               "edges": {
#                 "color": {
#                   "inherit": true
#                 },
#                 "font": {
#                   "size": 25,
#                   "strokeWidth": 3
#                 },
#                 "scaling": {
#                   "max": 14
#                 },
#                 "smooth": false
#               },
#               "interaction": {
#                 "tooltipDelay": 100
#               }
#             }
#             """)
        
#     # Create neighbour map (Optional for now)
#     sources = df[source_col]
#     targets = df[target_col]
#     weights = df[weights]

#     edge_data = zip(sources, targets, weights)
#     for e in edge_data:
#         src = e[0]
#         dst = e[1]
#         w = e[2]

#         df.add_node(src, src, title=src)
#         df.add_node(dst, dst, title=dst)
#         df.add_edge(src, dst, value=w)

#     # Add neighbor data to node hover data
#     # neighbor_map = df.get_adj_list()

#     # for node in db_net.nodes:

#     #     node['value'] = len(neighbor_map[node['id']])

    return drug_net

# Generate a networkx graph based on subset data
db_subset_net = generate_network_viz(data2, 'drug1_name', 'drug2_name', 'weight', layout='repulsion')

# Display interactive graph
db_subset_net.show('losemi_repulsion.html')

# Run the above code chunk in order to display the graph visualization below

# Generate a networkx graph based on subset data
db_subset_net_barnes = generate_network_viz(data2, 'drug1_name', 'drug2_name', 'weight', layout='barnes')
db_subset_net_barnes.show('losemi_barnes.html')

# Run the above code chunk in order to display the graph visualization below

# Create network for single drug. Use Tioguanine since it has most edges (i.e. involved in most drug interactions)
df_db_Tioguanine = data2.loc[data2['drug1_name'].isin(['Tioguanine']) | data2['drug2_name'].isin(['Tioguanine'])]

# Generate a networkx graph based on subset data
db_net_Tioguanine = generate_network_viz(df_db_Tioguanine, 'drug1_name', 'drug2_name', 'weight', layout='repulsion', spring_strength=0.05)
db_net_Tioguanine.show('drug_interactions_network_Tioguanine.html')

# Run the above code chunk in order to display the graph visualization below

df_db_Tioguanine

# Create network for single drug. Use Mercaptopurine since it has most edges (i.e. involved in most drug interactions)
df_db_Mercaptopurine = data2.loc[data2['drug1_name'].isin(['Mercaptopurine']) | data2['drug2_name'].isin(['Mercaptopurine'])]

# Generate a networkx graph based on subset data
db_net_Mercaptopurine = generate_network_viz(df_db_Mercaptopurine, 'drug1_name', 'drug2_name', 'weight', layout='repulsion', spring_strength=0.05)
db_net_Mercaptopurine.show('drug_interactions_network_Mercaptopurine.html')

# Run the above code chunk in order to display the graph visualization below

df_db_Mercaptopurine

# Create network for single drug. Use Dexamethasone since it has most edges (i.e. involved in most drug interactions)
df_db_Dexamethasone = data2.loc[data2['drug1_name'].isin(['Dexamethasone']) | data2['drug2_name'].isin(['Dexamethasone'])]

# Generate a networkx graph based on subset data
db_net_Dexamethasone = generate_network_viz(df_db_Dexamethasone, 'drug1_name', 'drug2_name', 'weight', layout='repulsion', spring_strength=0.05)
db_net_Dexamethasone.show('drug_interactions_network_Dexamethasone.html')

# Run the above code chunk in order to display the graph visualization below

df_db_Dexamethasone

# Create network for single drug. Use Prednisolon since it has most edges (i.e. involved in most drug interactions)
df_db_Prednisolone = data2.loc[data2['drug1_name'].isin(['Prednisolone']) | data2['drug2_name'].isin(['Prednisolone'])]

# Generate a networkx graph based on subset data
db_net_Prednisolone = generate_network_viz(df_db_Prednisolone, 'drug1_name', 'drug2_name', 'weight', layout='repulsion', spring_strength=0.05)
db_net_Prednisolone.show('drug_interactions_network_Prednisolone.html')

# Run the above code chunk in order to display the graph visualization below

df_db_Prednisolone

# Create network for single drug. Use Vincristine since it has most edges (i.e. involved in most drug interactions)
df_db_Vincristine = data2.loc[data2['drug1_name'].isin(['Vincristine']) | data2['drug2_name'].isin(['Vincristine'])]

# Generate a networkx graph based on subset data
db_net_Vincristine = generate_network_viz(df_db_Vincristine, 'drug1_name', 'drug2_name', 'weight', layout='repulsion', spring_strength=0.05)
db_net_Vincristine.show('drug_interactions_network_Vincristine.html')

# Run the above code chunk in order to display the graph visualization below

df_db_Vincristine

# Create network for single drug. Use Methotrexate since it has most edges (i.e. involved in most drug interactions)
df_db_Methotrexate = data2.loc[data2['drug1_name'].isin(['Methotrexate']) | data2['drug2_name'].isin(['Methotrexate'])]

# Generate a networkx graph based on subset data
db_net_Methotrexate = generate_network_viz(df_db_Methotrexate, 'drug1_name', 'drug2_name', 'weight', layout='repulsion', spring_strength=0.05)
db_net_Methotrexate.show('drug_interactions_network_Methotrexate.html')

# Run the above code chunk in order to display the graph visualization below

df_db_Methotrexate

# Create network for single drug. Use Daunorubicin since it has most edges (i.e. involved in most drug interactions)
df_db_Daunorubicin = data2.loc[data2['drug1_name'].isin(['Daunorubicin']) | data2['drug2_name'].isin(['Daunorubicin'])]

# Generate a networkx graph based on subset data
db_net_Daunorubicin = generate_network_viz(df_db_Daunorubicin, 'drug1_name', 'drug2_name', 'weight', layout='repulsion', spring_strength=0.05)
db_net_Daunorubicin.show('drug_interactions_network_Daunorubicin.html')

# Run the above code chunk in order to display the graph visualization below

df_db_Daunorubicin

# Create network for single drug. Use Cytarabine since it has most edges (i.e. involved in most drug interactions)
df_db_Cytarabine = data2.loc[data2['drug1_name'].isin(['Cytarabine']) | data2['drug2_name'].isin(['Cytarabine'])]

# Generate a networkx graph based on subset data
db_net_Cytarabine = generate_network_viz(df_db_Cytarabine, 'drug1_name', 'drug2_name', 'weight', layout='repulsion', spring_strength=0.05)
db_net_Cytarabine.show('drug_interactions_network_Cytarabine.html')

# Run the above code chunk in order to display the graph visualization below

df_db_Cytarabine

pip install streamlit pyvis networkx

triadic_closure2 = nx.transitivity(G2) #geçişlilik 0'dan 1'e kadar ölçeklenir, sonuç ağın yoğunluğundan biraz daha yüksek çıkmıştır
print("Triadic closure:", triadic_closure2)

d_dict2 = dict(G2.degree(G2.nodes()))
nx.set_node_attributes(G2, d_dict2, 'degree')

betweenness_dict2 = nx.betweenness_centrality(G2) # Run betweenness centrality
eigenvector_dict2 = nx.eigenvector_centrality(G2) # Run eigenvector centrality

# Assign each to an attribute in your network
nx.set_node_attributes(G2, betweenness_dict2, 'betweenness')
nx.set_node_attributes(G2, eigenvector_dict2, 'eigenvector')

sorted_betweenness2 = sorted(betweenness_dict2.items(), key=itemgetter(1), reverse=True)

print("Top 20 nodes by betweenness centrality:")
for b in sorted_betweenness2[:5]:
    print(b)

#First get the top 20 nodes by betweenness as a list
top_betweenness2 = sorted_betweenness2[:5]

#Then find and print their degree
for tb in top_betweenness2: # Loop through top_betweenness
    degree2 = degree_dict2[tb[0]] # Use degree_dict to access a node's degree, see footnote 2
    print("Name:", tb[0], "| Betweenness Centrality:", tb[1], "| Degree:", degree2)

communities2 = community.greedy_modularity_communities(G2)

modularity_dict2 = {} # Create a blank dictionary
for i,c in enumerate(communities2): # Loop through the list of communities, keeping track of the number for the community
    for name in c: # Loop through each person in a community
        modularity_dict2[name] = i # Create an entry in the dictionary for the person, where the value is which group they belong to.

# Now you can add modularity information like we did the other metrics
nx.set_node_attributes(G2, modularity_dict2, 'modularity')

# First get a list of just the nodes in that class
class0 = [n for n in G2.nodes() if G2.nodes[n]['modularity'] == 0]

# Then create a dictionary of the eigenvector centralities of those nodes
class0_eigenvector = {n:G2.nodes[n]['eigenvector'] for n in class0}

# Then sort that dictionary and print the first 5 results
class0_sorted_by_eigenvector = sorted(class0_eigenvector.items(), key=itemgetter(1), reverse=True)

print("Modularity Class 0 Sorted by Eigenvector Centrality:")
for node in class0_sorted_by_eigenvector[:5]:
    print("Name:", node[0], "| Eigenvector Centrality:", node[1])

for i,c in enumerate(communities2): # Loop through the list of communities
    if len(c) > 2: # Filter out modularity classes with 2 or fewer nodes
        print('Class '+str(i)+':', list(c)) # Print out the classes and their members

nx.write_gexf(G2, 'quaker_.gexf')